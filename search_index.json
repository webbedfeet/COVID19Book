[
["index.html", "Understanding the COVID-19 pandemic A data-driven approach using the sars2pack R package 1 Motivation 1.1 Origins of this package", " Understanding the COVID-19 pandemic A data-driven approach using the sars2pack R package Vincent Carey Charles Morefield John Mallery Sean Davis 2020-04-02 1 Motivation The COVID-19 pandemic is ongoing. The situation on the ground is changing daily as captured by data reported around the world. The sars2pack package aims to: Provide timely, computable, easily accessible data for research, policy-making, and educational purposes. Promote easy computational experimentation with COVID-19 data Serve as a source of documentation and education for available COVID-19 analysis and visualization approaches. House recipes for regularly updated data products such as spreadsheets and maps for use by non-R-savvy data consumers. Collect interesting data stories along with code as data science training resources for the many biomedical researchers who cannot currently perform experiments 1.1 Origins of this package John C. Mallery conveyed code of Charles Morefield to harvest COVID-19 time series data. Vince Carey then started an R package/github repo to manage the relevant code. The package was named sars2pack in hopes of avoiding name conflict with many other packages while remaining descriptive and focused. ## Warning: package &#39;BiocStyle&#39; was built under R version 3.6.2 ## Warning: package &#39;tibble&#39; was built under R version 3.6.2 "],
["quick-start.html", "2 Quick start 2.1 Installation 2.2 COVID-19 resources in this package", " 2 Quick start 2.1 Installation BiocManager::install(&#39;seandavi/sars2pack&#39;) 2.2 COVID-19 resources in this package The COVID-19 data in this package are, right now, focused toward time-series descriptions of confirmed cases, deaths, testing, and recovered cases. There is no requirement that this remain the case. Contributions of additional data resources or simple accessor functions will only add to our abilities to use data science and modeling to understand COVID-19. Request for help: We are looking for additional data resources. Consider a pull request (or an issue for non-programmer types) with suggestions. "],
["todo-give-background-on-datasets.html", "3 TODO: give background on datasets", " 3 TODO: give background on datasets "],
["epidemic-time-series-data.html", "4 Epidemic time series data 4.1 Access data", " 4 Epidemic time series data Usage of each of the time series datasets follows a similar pattern. Fetch a tidy tbl_df using a function such as jhu_data() In the resulting tbl_df, the columns date (of type date) and count of type numeric columns are standard. Additional columns describe locations, subsets of data (such as confirmed, deaths, recovered) and vary from dataset to dataset. Regardless of the original format of the data, the sars2pack datasets are presented as tidy data to facilitate dplyr, ggplot, and other fluid analysis approaches to apply directly. 4.1 Access data This section briefly introduces how to access the data resources in this package. Note that many of the functions below require a network connection to get updated data. 4.1.1 JHU Dataset jhu = jhu_data() class(jhu) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(jhu) ## [1] 39300 7 Column names include: colnames(jhu) ## [1] &quot;ProvinceState&quot; &quot;CountryRegion&quot; &quot;Lat&quot; &quot;Long&quot; ## [5] &quot;date&quot; &quot;count&quot; &quot;subset&quot; And a very small subset of the data. head(jhu,3) ## # A tibble: 3 x 7 ## ProvinceState CountryRegion Lat Long date count subset ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 &lt;NA&gt; Afghanistan 33 65 2020-01-22 0 confirmed ## 2 &lt;NA&gt; Afghanistan 33 65 2020-01-23 0 confirmed ## 3 &lt;NA&gt; Afghanistan 33 65 2020-01-24 0 confirmed 4.1.2 USAFacts Dataset usa_facts = usa_facts_data() class(usa_facts) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(usa_facts) ## [1] 434792 7 Column names include: colnames(usa_facts) ## [1] &quot;county_fips&quot; &quot;county&quot; &quot;state&quot; &quot;state_fips&quot; &quot;subset&quot; ## [6] &quot;date&quot; &quot;count&quot; And a very small subset of the data. head(usa_facts,3) ## # A tibble: 3 x 7 ## county_fips county state state_fips subset date count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 0 Statewide Unallocated AL 1 confirmed 2020-01-22 0 ## 2 0 Statewide Unallocated AL 1 confirmed 2020-01-23 0 ## 3 0 Statewide Unallocated AL 1 confirmed 2020-01-24 0 4.1.3 NYTimes datasets nytimes_state = nytimes_state_data() class(nytimes_state) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(nytimes_state) ## [1] 3658 5 Column names include: colnames(nytimes_state) ## [1] &quot;date&quot; &quot;state&quot; &quot;fips&quot; &quot;count&quot; &quot;subset&quot; And a very small subset of the data. head(nytimes_state,3) ## # A tibble: 3 x 5 ## date state fips count subset ## &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2020-01-21 Washington 00053 1 confirmed ## 2 2020-01-22 Washington 00053 1 confirmed ## 3 2020-01-23 Washington 00053 1 confirmed nytimes_county = nytimes_county_data() class(nytimes_county) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(nytimes_county) ## [1] 66502 6 colnames(nytimes_county) ## [1] &quot;date&quot; &quot;county&quot; &quot;state&quot; &quot;fips&quot; &quot;count&quot; &quot;subset&quot; "],
["use-cases.html", "5 Use cases 5.1 Basic data exploration 5.2 Visualize time series data", " 5 Use cases 5.1 Basic data exploration In this section, we will be using a combination of [dplyr] and [ggplot2] to explore the COVID-19 global data from JHU. For details on this dataset, see the help using ?jhu_data. The next line of code will do a (set of) network calls to fetch the most up-to-date dataset from the JHU github repository. jhu = jhu_data() head(jhu,3) ## # A tibble: 3 x 7 ## ProvinceState CountryRegion Lat Long date count subset ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 &lt;NA&gt; Afghanistan 33 65 2020-01-22 0 confirmed ## 2 &lt;NA&gt; Afghanistan 33 65 2020-01-23 0 confirmed ## 3 &lt;NA&gt; Afghanistan 33 65 2020-01-24 0 confirmed We now want to ask a series of questions about the dataset. How many records are in the dataset? nrow(jhu) ## [1] 39300 How many different countries are represented? length(unique(jhu$CountryRegion)) ## [1] 183 Most records have no listing for ProvinceState column. Let’s look at a few of those to get an idea of what is there when not empty: What is in the ProvinceState column? To answer this question, we will be using dplyr, so some familiarity with that package will be helpful to follow this code. jhu %&gt;% dplyr::filter(!is.na(ProvinceState)) %&gt;% dplyr::select(ProvinceState, CountryRegion) %&gt;% unique() %&gt;% head(10) ## # A tibble: 10 x 2 ## ProvinceState CountryRegion ## &lt;chr&gt; &lt;chr&gt; ## 1 Australian Capital Territory Australia ## 2 New South Wales Australia ## 3 Northern Territory Australia ## 4 Queensland Australia ## 5 South Australia Australia ## 6 Tasmania Australia ## 7 Victoria Australia ## 8 Western Australia Australia ## 9 Alberta Canada ## 10 British Columbia Canada We still have not looked at the most valuable information, the date and count columns in any detail. What is the current count of confirmed cases by country, ordered by highest count down? There is a lot to unpack in the next code block, but the results are quite useful. We will use the DT package to make the dataset searchable and sortable. library(DT) latest_jhu_data = jhu %&gt;% dplyr::filter(subset==&#39;confirmed&#39; &amp; is.na(ProvinceState)) %&gt;% dplyr::group_by(CountryRegion) %&gt;% dplyr::slice(which.max(date)) %&gt;% dplyr::arrange(desc(count)) DT::datatable(latest_jhu_data, rownames=FALSE) Note: I included a little is.na in the filtering above to remove records where country data are split out over subparts. We revisit this below. The data here could be usefully displayed as a graph as well. par(las=2, mar=c(8,5,5,1)) barplot(count ~ CountryRegion, xlab = &#39;&#39;, data=head(latest_jhu_data,10), main=&#39;Confirmed cases, top 10 countries&#39;) We note here that China is not shown. That is because we limited the data to only rows that had empty ProvinceState records. To add those records back in, we sum all the China rows (and those of other countries like Australia, etc.) by country and then perform similar work to produce a final plot. latest_jhu_data = jhu %&gt;% dplyr::filter(subset==&#39;confirmed&#39;) %&gt;% dplyr::select(-c(ProvinceState,Lat,Long)) %&gt;% dplyr::group_by(CountryRegion,date) %&gt;% dplyr::summarize(count = sum(count)) %&gt;% dplyr::slice(which.max(date)) %&gt;% dplyr::arrange(desc(count)) par(las=2, mar=c(8,5,5,1)) barplot(count ~ CountryRegion, xlab = &#39;&#39;, data=head(latest_jhu_data,10), main=&#39;Confirmed cases, top 10 countries&#39;) 5.2 Visualize time series data Up to now, we have ignored the time series aspects of the data and have sliced the dataset by country. In this section, we will be using dplyr and ggplot2 to visualize disease infection and deaths over time. How have the cases in Italy changed over time? library(ggplot2) italy_cc_ts = jhu %&gt;% dplyr::filter(CountryRegion == &#39;Italy&#39; &amp; subset==&#39;confirmed&#39;) ggplot(italy_cc_ts,aes(x=date, y=count)) + geom_line() + ggtitle(&#39;Confirmed cases&#39;) How do the confirmed cases in China, US, Italy, Spain, Germany, and Russia compare over time? We have to play the same game of summing all values by country and date. Here, we filter the countries to be in a list of countries. countries_of_interest = c(&#39;China&#39;,&#39;US&#39;,&#39;Italy&#39;,&#39;Spain&#39;,&#39;Germany&#39;,&#39;Russia&#39;) library(ggplot2) cc_ts = jhu %&gt;% dplyr::group_by(CountryRegion,date) %&gt;% dplyr::filter(CountryRegion %in% countries_of_interest &amp; subset==&#39;confirmed&#39;) %&gt;% dplyr::summarize(count = sum(count)) head(cc_ts) ## # A tibble: 6 x 3 ## # Groups: CountryRegion [1] ## CountryRegion date count ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 China 2020-01-22 548 ## 2 China 2020-01-23 643 ## 3 China 2020-01-24 920 ## 4 China 2020-01-25 1406 ## 5 China 2020-01-26 2075 ## 6 China 2020-01-27 2877 To make the plot, we use the ggplot2 grouping and coloring to provide curves for each country on the same axis. ggplot(cc_ts,aes(x=date, y=count, group=CountryRegion)) + geom_line(aes(color=CountryRegion)) + ggtitle(&#39;Confirmed cases&#39;) Changing to log scale can give a sense of the “exponentialness” of these data. Also, to remove zeros from the data (which cause problems when taking logs), we can filter data to include only values &gt;=50. Note that ggplot2 will “do the right thing”. cc_ts %&gt;% dplyr::filter(count&gt;=50) %&gt;% ggplot(aes(x=date, y=count, group=CountryRegion)) + geom_line(aes(color=CountryRegion)) + ggtitle(&#39;Confirmed cases&#39;) + scale_y_log10() Consider the following questions based on the figure: What does the slope of the lines in this plot represent? What is the difference between China and other countries? What does this difference mean in terms of how the disease is spreading? What does each Pick an arbitrary level on the y-axis and look at the dates associated with each country’s curve with respect to that level. What do differences along the x-axis tell us about where the countries are with respect to disease process? "],
["the-replication-rate-r-0.html", "6 The Replication rate, \\(R_0\\) 6.1 Learning goals and objectives 6.2 Background 6.3 Simulated epidemic model 6.4 Real data examples", " 6 The Replication rate, \\(R_0\\) 6.1 Learning goals and objectives Gain an intuitive understanding of \\(R_0\\). Know that the value of \\(R_0\\) determines how quickly a disease spreads or is eliminated. Name the three main drivers of \\(R_0\\) Learn to estimate \\(R_0\\) from data on the number of infections over time occurring in a population. 6.2 Background The replication rate, \\(R_0\\) is a central value in understanding the rate at which a disease is spreading in a susceptible population. 6.2.1 What is \\(R_0\\)? \\(R_0\\) is pronounced “R naught.” The \\(R_0\\) value is an estimate of the average number of people who will be infected by one contagious person. It specifically applies to a population of people who are susceptible to the disease (have not been vaccinated and are not immune). If a disease has an \\(R_0\\) of 18, for example, a contagious person will transmit it to an average of 18 other people, assuming that all people in the community are susceptible. 6.2.2 What do \\(R_0\\) values mean? The \\(R_0\\) value of a disease is important to understanding the dynamics of disease spread. Depending on the \\(R_0\\) value, a disease should follow one of three possible courses in the at-risk community. If \\(R_0\\) is less than 1, each existing infection is spread on average to less than one additional person, leading to decline in the number of cases and eventual end to the spread. If \\(R_0\\) equals 1, each existing infection causes one new infection, leading to stable infection numbers without increase or decrease with time, on average. If \\(R_0\\) is more than 1, each existing infection leads to more than one infection, resulting in growth and potential for epidemic/pandemic conditions. Importantly, the disease-specific \\(R_0\\) value pplies when each member of the community is fully vulnerable to the disease with: no one vaccinated no one immune no way to control the spread of the disease 6.2.3 What variables contribute to \\(R_0\\)? Three main factors impact the \\(R_0\\) value of a disease: Infectious period: The time that an infected person can spread the disease varies from one disease to another. Additional factors such as age of the infected person may affect the period during which a person can infect others. A long period of infectiousness will contribute to a higher \\(R_0\\) value. Contact rate: If a person who’s infected with a contagious disease comes into contact with many people who aren’t infected or vaccinated, the disease will spread more quickly. If that person remains at home, in a hospital, or otherwise quarantined while they’re contagious, the disease will spread more slowly. A high contact rate will contribute to a higher \\(R_0\\) value. The corollary, that lower contact rate, can reduce \\(R_0\\) is the basis for flattening the curve through social distancing. Toby Morris (Spinoff.co.nz) / CC BY-SA (https://creativecommons.org/licenses/by-sa/4.0) Mode of transmission: Airborne illnesses tend to have a higher \\(R_0\\) value than those spread through contact or through bodily fluids. 6.3 Simulated epidemic model TODO: plot of incidence along with \\(R_0(t)\\) Following code conveyed by John Mallery, we have the following approach for estimating \\(R_0\\) using a single realization of an epidemic simulation. Note that there can be failures of estimate.R for certain inputs. We are working on that. library(sars2pack) library(R0) library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date # Generating an epidemic with given parameters mGT &lt;- generation.time(&quot;gamma&quot;, c(3,1.5)) set.seed(5432) # always initialize when simulating! mEpid &lt;- sim.epid(epid.nb=1, GT=mGT, epid.length=30, family=&quot;poisson&quot;, R0=1.67, peak.value=500) mEpid &lt;- mEpid[,1] # Running estimations est &lt;- estimate.R(epid=mEpid, GT=mGT, methods=c(&quot;EG&quot;,&quot;ML&quot;,&quot;TD&quot;), begin=1, end=30) ## Waiting for profiling to be done... ## Warning in est.R0.TD(epid = c(1, 0, 1, 0, 1, 0, 2, 1, 2, 1, 7, 2, 3, 4, : ## Simulations may take several minutes. ## Warning in est.R0.TD(epid = c(1, 0, 1, 0, 1, 0, 2, 1, 2, 1, 7, 2, 3, 4, : Using ## initial incidence as initial number of cases. We modified the plotting function in R0 which was calling dev.new too often. Use plot2. par(mfrow=c(2,2)) sars2pack::plot2(est) The plotfit2 function is also useful. These fits look identical but they are not. par(mfrow=c(2,2)) sars2pack::plotfit2(est) 6.4 Real data examples library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:lubridate&#39;: ## ## intersect, setdiff, union ## The following object is masked from &#39;package:MASS&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(magrittr) Now we extract information from the time-series table and obtain estimates of \\(R_0\\) under exponential growth. 6.4.1 Hubei Province We are able to use exponential growth and time-dependent models with this data, using generation time model from a recent Annals of Internal Medicine paper. The incidence data probably need smoothing, and the time-dependent model has unreasonable fluctuations. dates = lubridate::as_date(mdy(names(mar19df)[-c(1:4)])) hubdat = as.numeric(get_series(province=&quot;Hubei&quot;, country=&quot;China&quot;, dataset=sars2pack::mar19df)) names(hubdat) = dates mGT &lt;- generation.time(&quot;gamma&quot;, c(5.8, 0.95)) # from DOI 10.7326/M20-0504 mGT &lt;- generation.time(&quot;gamma&quot;, c(3.96, 4.75)) # from DOI 10.7326/M20-0504 hubdat.filt = trim_leading_values(c(hubdat[1], diff(hubdat))) est.EG &lt;- estimate.R(epid=hubdat.filt, GT=mGT, methods=c(&quot;EG&quot;, &quot;TD&quot;), begin=1L, end=as.integer(length(hubdat.filt))) ## Waiting for profiling to be done... ## Warning in est.R0.TD(epid = c(`2020-01-22` = 444, `2020-01-23` = 0, `2020-01-24` ## = 105, : Simulations may take several minutes. ## Warning in est.R0.TD(epid = c(`2020-01-22` = 444, `2020-01-23` = 0, `2020-01-24` ## = 105, : Using initial incidence as initial number of cases. est.EG ## Reproduction number estimate using Exponential Growth method. ## R : 0.8190473[ 0.8164334 , 0.821658 ] ## ## Reproduction number estimate using Time-Dependent method. ## 2.020789 0 3.0142 3.134995 3.32356 3.865543 1.596743 0 1.878637 2.079345 ... par(mfrow=c(2,2), mar=c(5,3,2,2)) plot2(est.EG) plotfit2(est.EG) 6.4.2 Italy For Italy, only the EG model seems to work, with the Annals of Internal Medicine generation time model. It fits the data reasonably well, but the data seems to include a reporting gap. itdat = as.numeric(get_series(province=&quot;&quot;, country=&quot;Italy&quot;, dataset=sars2pack::mar19df)) names(itdat) = dates itdat.filt = trim_leading_values(c(itdat[1], diff(itdat))) est.EG &lt;- estimate.R(epid=itdat.filt, GT=mGT, methods=c(&quot;EG&quot;), begin=1L, end=as.integer(length(itdat.filt))) ## Waiting for profiling to be done... est.EG ## Reproduction number estimate using Exponential Growth method. ## R : 1.968466[ 1.957161 , 1.979874 ] par(mfrow=c(2,1), mar=c(5,3,2,2)) plot2(est.EG, main=&quot;Italy&quot;) plotfit2(est.EG, main=&quot;Italy&quot;) 6.4.3 New York City TODO: plot of incidence along with \\(R_0(t)\\) nyt = nytimes_county_data() %&gt;% dplyr::filter(county==&#39;New York City&#39; &amp; subset==&#39;confirmed&#39;) %&gt;% dplyr::arrange(date) nytdat = nyt$count # do we need to chop zeros off? Seems like not. nytdat.filt = c(nytdat[1], diff(nytdat)) est &lt;- estimate.R(epid=nytdat.filt, GT=mGT, methods=c(&quot;EG&quot;,&quot;TD&quot;,&quot;ML&quot;), begin=1L, end=as.integer(length(nytdat.filt))) We can also use the package EpiEstim to perform time-dependent \\(R_0\\) calculations. library(EpiEstim) ## ## Attaching package: &#39;EpiEstim&#39; ## The following object is masked from &#39;package:sars2pack&#39;: ## ## estimate_R epiestim = EpiEstim::estimate_R(nytdat.filt, method = &quot;parametric_si&quot;, config = EpiEstim::make_config(list( mean_si = 3.96, std_si = 4.75))) ## Default config will estimate R on weekly sliding windows. ## To change this change the t_start and t_end arguments. invisible(plot(epiestim)) "],
["european-datasets.html", "7 European datasets", " 7 European datasets library(knitr) knitr::opts_chunk$set(message=FALSE) library(sars2pack) library(eurostat) library(dplyr) library(tmap) library(sf) eucov = eu_data_cache_data() geodata = get_eurostat_geospatial(output_class = &quot;sf&quot;, resolution = &quot;60&quot;, nuts_level = 2, year=2016) ## The names here need to be initialized to NULL ## for the join below to working ## See https://github.com/r-spatial/sf/issues/1177#issuecomment-541858742 head(names(geodata$geometry)) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; names(geodata$geometry)=NULL x = left_join(geodata, eucov, by=c(&#39;NUTS_NAME&#39;=&#39;nuts_2&#39;)) tmap::tm_shape(geodata) + tm_polygons() x %&gt;% filter(date==&#39;2020-04-01&#39;) %&gt;% tmap::tm_shape() + tm_polygons(col=&#39;cases&#39;) "],
["epicurve-datasets.html", "8 Epicurve Datasets 8.1 Worldwide datasets 8.2 European datasets 8.3 United States datasets", " 8 Epicurve Datasets library(sars2pack) ## Loading required package: R0 ## Loading required package: MASS ## Loading required package: sf ## Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0 library(DT) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:MASS&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union 8.1 Worldwide datasets jhu = jhu_data() DT::datatable(jhu[sample(1:nrow(jhu),500),] %&gt;% dplyr::arrange(CountryRegion, date), extensions = &#39;Scroller&#39;, options = list(scrollX=TRUE)) 8.2 European datasets eucov = eu_data_cache_data() DT::datatable(eucov[sample(1:nrow(eucov),500),] %&gt;% dplyr::arrange(country, date), extensions = &#39;Scroller&#39;, options = list(scrollX=TRUE)) 8.3 United States datasets 8.3.1 USAFacts usa_facts = usa_facts_data() DT::datatable(usa_facts[sample(1:nrow(usa_facts),500),] %&gt;% dplyr::arrange(state, county, date, subset), extensions = &#39;Scroller&#39;, options = list(scrollX=TRUE)) 8.3.2 New York Times County nytimes = nytimes_county_data() DT::datatable(nytimes[sample(1:nrow(nytimes),500),] %&gt;% dplyr::arrange(state, county, date, subset), extensions = &#39;Scroller&#39;, options = list(scrollX=TRUE)) 8.3.3 New York Times State nytimes = nytimes_state_data() DT::datatable(nytimes[sample(1:nrow(nytimes),500),] %&gt;% dplyr::arrange(state, date, subset), extensions = &#39;Scroller&#39;, options = list(scrollX=TRUE)) "],
["map-visualizations.html", "9 Map visualizations 9.1 Interactive maps 9.2 United States", " 9 Map visualizations library(tmap) library(dplyr) library(sars2pack) library(htmltools) library(htmlwidgets) ejhu = enriched_jhu_data() glimpse(ejhu) ## Rows: 39,300 ## Columns: 20 ## $ name &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanis… ## $ topLevelDomain &lt;list&gt; [&quot;.af&quot;, &quot;.af&quot;, &quot;.af&quot;, &quot;.af&quot;, &quot;.af&quot;, &quot;.af&quot;, &quot;.af&quot;, &quot;.a… ## $ alpha2Code &lt;chr&gt; &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, … ## $ alpha3Code &lt;chr&gt; &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;… ## $ capital &lt;chr&gt; &quot;Kabul&quot;, &quot;Kabul&quot;, &quot;Kabul&quot;, &quot;Kabul&quot;, &quot;Kabul&quot;, &quot;Kabul&quot;, … ## $ region &lt;chr&gt; &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;… ## $ subregion &lt;chr&gt; &quot;Southern Asia&quot;, &quot;Southern Asia&quot;, &quot;Southern Asia&quot;, &quot;So… ## $ population &lt;int&gt; 27657145, 27657145, 27657145, 27657145, 27657145, 2765… ## $ area &lt;dbl&gt; 652230, 652230, 652230, 652230, 652230, 652230, 652230… ## $ gini &lt;dbl&gt; 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, … ## $ borders &lt;list&gt; [&lt;&quot;IRN&quot;, &quot;PAK&quot;, &quot;TKM&quot;, &quot;UZB&quot;, &quot;TJK&quot;, &quot;CHN&quot;&gt;, &lt;&quot;IRN&quot;, … ## $ numericCode &lt;chr&gt; &quot;004&quot;, &quot;004&quot;, &quot;004&quot;, &quot;004&quot;, &quot;004&quot;, &quot;004&quot;, &quot;004&quot;, &quot;004&quot;… ## $ cioc &lt;chr&gt; &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;… ## $ ProvinceState &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ CountryRegion &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanis… ## $ Lat &lt;dbl&gt; 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33… ## $ Long &lt;dbl&gt; 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65… ## $ date &lt;date&gt; 2020-01-22, 2020-01-23, 2020-01-24, 2020-01-25, 2020-… ## $ count &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ subset &lt;chr&gt; &quot;confirmed&quot;, &quot;confirmed&quot;, &quot;confirmed&quot;, &quot;confirmed&quot;, &quot;c… We need a description of the regions of the world. data(World) The World object has a column, geometry, that describes the shape of each country in the World dataset. Join the ejhu data.frame with the World data using dplyr join as normal. geo_ejhu = World %&gt;% dplyr::left_join(ejhu, by = c(&#39;iso_a3&#39; = &#39;alpha3Code&#39;)) w2 = geo_ejhu %&gt;% filter(!is.na(date) &amp; subset==&#39;confirmed&#39;) %&gt;% group_by(iso_a3) %&gt;% filter(date==max(date)) %&gt;% mutate(cases_per_million = 1000000*count/pop_est) The R package ggplot2 has geospatial plotting capabilities built in for geospatial simple features (sf) data types. In this first plot, we focus in on Europe. library(ggplot2) # transform to lat/long coordinates st_transform(w2, crs=4326) %&gt;% # Crop to europe (rough, by hand) st_crop(xmin=-20,xmax=45,ymin=35,ymax=70) %&gt;% ggplot() + geom_sf(aes(fill=cases_per_million)) + scale_fill_continuous( guide=guide_legend(label.theme = element_text(angle = 90), label.position=&#39;bottom&#39;) ) + labs(title=&#39;Cases per Million Inhabitants&#39;) + theme(legend.position=&#39;bottom&#39;) Another plot, but now for Africa. library(ggplot2) # transform to lat/long coordinates st_transform(w2, crs=4326) %&gt;% # Crop to europe (rough, by hand) st_crop(xmin=-20,xmax=50,ymin=-60,ymax=25) %&gt;% ggplot() + geom_sf(aes(fill=cases_per_million)) + scale_fill_continuous( guide=guide_legend(label.theme = element_text(angle = 90), label.position=&#39;bottom&#39;) ) + labs(title=&#39;Cases per Million Inhabitants&#39;) + theme(legend.position=&#39;bottom&#39;) 9.1 Interactive maps The following will not produce a plot when run non-interactively. However, pasting this into your R session will result in an interactive plot with multiple “layers” that you can choose to visualize different quantitative variables on the map. Zooming also works as expected. tmap_mode(&#39;view&#39;) ## geo_ejhu %&gt;% ## filter(!is.na(date) &amp; subset==&#39;confirmed&#39;) %&gt;% ## group_by(iso_a3) %&gt;% ## filter(date==max(date)) %&gt;% ## tm_shape() + ## tm_polygons(col=&#39;count&#39;) w2 = geo_ejhu %&gt;% filter(!is.na(date) &amp; subset==&#39;confirmed&#39;) %&gt;% group_by(iso_a3) %&gt;% filter(date==max(date)) %&gt;% mutate(cases_per_million = 1000000*count/pop_est) %&gt;% filter(region == &#39;Africa&#39;) m = tm_shape(w2,id=&#39;name.x&#39;, name=c(&#39;cases_per_million&#39;),popup=c(&#39;pop_est&#39;)) + tm_polygons(c(&#39;Cases Per Million&#39; = &#39;cases_per_million&#39;,&#39;Cases&#39; = &#39;count&#39;,&quot;Well-being index&quot;=&#39;well_being&#39;, &#39;GINI&#39;=&#39;gini&#39;), selected=&#39;cases_per_million&#39;, border.alpha = 0.5, alpha=0.6, popup.vars=c(&#39;Cases Per Million&#39;=&#39;cases_per_million&#39;, &#39;Confirmed Cases&#39; =&#39;count&#39;, &#39;Population&#39; =&#39;pop_est&#39;, &#39;gini&#39; =&#39;gini&#39;, &#39;Life Expectancy&#39; =&#39;life_exp&#39;)) + tm_facets(as.layers = TRUE) tmap_save(m, filename=&#39;abc.html&#39;) 9.2 United States library(ggplot2) library(tigris) library(tidycensus) library(plotly) library(sf) county_geom = tidycensus::county_laea nyt_counties = nytimes_county_data() full_map = county_geom %&gt;% left_join( nyt_counties %&gt;% group_by(fips) %&gt;% filter(date==max(date) &amp; count&gt;0 &amp; subset==&#39;confirmed&#39;), by=c(&#39;GEOID&#39;=&#39;fips&#39;)) %&gt;% mutate(mid=sf::st_centroid(geometry)) z = ggplot(full_map, aes(label=county)) + geom_sf(aes(geometry=geometry),color=&#39;grey85&#39;) + geom_sf(aes(geometry=mid, size=count, color=count), alpha=0.5, show.legend = &quot;point&quot;) + scale_color_gradient2(midpoint=5500, low=&quot;lightblue&quot;, mid=&quot;orange&quot;,high=&quot;red&quot;, space =&quot;Lab&quot; ) + scale_size(range=c(1,10)) ggplotly(z) United States confirmed cases by County with interactive plotly library. Click and drag to zoom in to a region of interest. A static plot as a png: z United States confirmed cases by County as a static graphic. Alternatively, produce a PDF of the same plot. pdf(&#39;us_county_numbers.pdf&#39;, width=11, height=8) print(z) dev.off() ## quartz_off_screen ## 2 "]
]
